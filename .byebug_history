query_minimum_should_match
c
mapped_key
c
mapped_key
c
mapped_key
c
mapped_key
c
path
mapped_key
scope2
scope
c
mapping[key]
mapped_key
path
scope
c
hash
parent
c
(object[:and].length == 1 && object[:or].empty? && object[:not].empty?)
is_simple_filter
c
to_merge
next
type == :queries && has_filters?
next
type
c
type == :queries
has_filters?
type
c
has_filters?
c
(object[:and].length == 1 && object[:or].empty? && object[:not].empty?)
c
(object[:and].length == 1 && object[:or].empty? && object[:not].empty?)
c
type
mapping
is_simple_filter
c
filters[:and]
filters[:or]
filters[:not]
filters.values
queries
filters
parent.type == 'nested'
parent.type
parent.class
parent
c
hash
clauses
object
type
acum
type
hash
key
c
child_hash
c
child_hash
c
hash
c
hash
c
parent
hash
c
hash
parent
c
hash
c
object[:and].length == 1 && object[:or].empty? && object[:not].empty?
to_merge
c
to_merge
obj
c
obj
path.reverse.inject({}){|acum, key| {"#{key}".to_s => hash } }
hash
obj
c
bool_filters
bool_queries
c
type
ctx.has_queries?
has_queries?
filters_and_queries[:queries]
filters_and_queries[:filters]
type
c
@queries
 bool_queries
bool_filters
c
bool_queries
bool_filters
c
bool_filters
bool_queries
c
bool_queries
c
bool_queries
c
bool_queries
c
k.to_s
acum
c
bool_queries[:bool].keys
bool_queries[:bool]
bool_queries
c
hhh
c
hhh
c
acum
o
acum
hash
next
hash
c
hash
c
o[1].key?(:must)
o[1]
o
c
to_merge
c
child_hash
c
hash
child_hash
c
child_hash
hash
type
c
hash
type
c
hash
JSON.parse("{\"query\":{\"nested\":{\"path\":\"obj1\",\"query\":{\"must\":[{\"match\":{\"obj1.name\":\"blue\"}},{\"range\":{\"obj1.count\":{\"gt\":5}}}]},\"score_mode\":\"avg\"}}}")
c
options
hash
child_hash
type
child_hash
options
otpions
c
options
c
options
c
options
c
type
child_hash
type
c
hash
type
c
type
c
bool_queries
c
bool_queries
query
c
query
uery
bool_queries
c
type
hash
type
c
type
value
field
@type
c
child_hash
c
next
bool_queries
bool_filters
c
query
bool_queries
c
bool_queries
bool_queries[:bool]
bool_queries
bool_queries.key?(:bool)
bool_queries
c
query
h.to_s
c
path
h.to_s
path
c
h.to_s
h
c
[:a, :b].to_h
SuperHash::Utils.flatten_to_root(to_merge[1][1])
to_merge[0]
to_merge[1]
query
to_merge.each{|obj| SuperHash::Utils.bury(query, *to_merge[1][0], to_merge[1][1]) }
query
to_merge.each{|obj| SuperHash::Utils.bury(query, *to_merge[0][0], to_merge[0][1]) }
to_merge[0]
to_merge
query = Marshal.load(Marshal.dump(base_query))
query
to_merge.each{|obj| SuperHash::Utils.bury(query, *obj[0], obj[1]) }
query
query = Marshal.load(Marshal.dump(base_query))
query
to_merge[0]
to_merge
query
next
to_merge
parent
next
to_merge
next
bool_filters
bool_filters.empty?
bool_filters.empty
bool_filters
to_merge
