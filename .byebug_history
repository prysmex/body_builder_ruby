c
bool_filters
bool_queries
c
bool_queries
c
bool_queries
c
bool_queries
c
k.to_s
acum
c
bool_queries[:bool].keys
bool_queries[:bool]
bool_queries
c
hhh
c
hhh
c
acum
o
acum
hash
next
hash
c
hash
c
o[1].key?(:must)
o[1]
o
c
to_merge
c
child_hash
c
hash
child_hash
c
child_hash
hash
type
c
hash
type
c
hash
JSON.parse("{\"query\":{\"nested\":{\"path\":\"obj1\",\"query\":{\"must\":[{\"match\":{\"obj1.name\":\"blue\"}},{\"range\":{\"obj1.count\":{\"gt\":5}}}]},\"score_mode\":\"avg\"}}}")
c
options
hash
child_hash
type
child_hash
options
otpions
c
options
c
options
c
options
c
type
child_hash
type
c
hash
type
c
type
c
bool_queries
c
bool_queries
query
c
query
uery
bool_queries
c
type
hash
type
c
type
value
field
@type
c
child_hash
c
next
bool_queries
bool_filters
c
query
bool_queries
c
bool_queries
bool_queries[:bool]
bool_queries
bool_queries.key?(:bool)
bool_queries
c
query
h.to_s
c
path
h.to_s
path
c
h.to_s
h
c
[:a, :b].to_h
SuperHash::Utils.flatten_to_root(to_merge[1][1])
to_merge[0]
to_merge[1]
query
to_merge.each{|obj| SuperHash::Utils.bury(query, *to_merge[1][0], to_merge[1][1]) }
query
to_merge.each{|obj| SuperHash::Utils.bury(query, *to_merge[0][0], to_merge[0][1]) }
to_merge[0]
to_merge
query = Marshal.load(Marshal.dump(base_query))
query
to_merge.each{|obj| SuperHash::Utils.bury(query, *obj[0], obj[1]) }
query
query = Marshal.load(Marshal.dump(base_query))
query
to_merge[0]
to_merge
query
next
to_merge
parent
next
to_merge
next
bool_filters
bool_filters.empty?
bool_filters.empty
bool_filters
to_merge
next
bool_queries
bool_filters
c
bool_filters
c
bool_filters
